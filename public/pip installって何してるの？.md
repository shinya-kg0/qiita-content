---
title: pip installって何してるの？
tags:
  - 'Python'
  - '初心者'
private: false
updated_at: ''
id: null
organization_url_name: null
slide: false
ignorePublish: false
---
# はじめに

Pythonでプログラミングをしていると、当たり前のように使っている`pip install`コマンド。
このコマンド一つで、便利なライブラリがすぐに使えるようになります。

しかし、**結局、pipは何をどこにダウンロードして、どうやってPythonがそれを見つけているのか？**を詳しく知っている人は意外と少ないかもしれません。

普段は意識しなくても開発は進められますが、
以下のような場面では内部の仕組みを理解していると役立ちます。

- ライブラリをインストールしたはずなのに`ModuleNotFoundError`が出るというトラブルの解決
- 特定のプロジェクトだけで自作ライブラリを使い回したいときの構成
- 複数のライブラリのバージョン競合（依存関係）で詰まったときの原因究明


この記事では、pip installが内部でどのような処理を行っているのかを、できるだけシンプルに解説します。


# pip installの基本的な流れ

`pip install`を実行したとき、内部では大きく分けて
「探す」「置く」「つなげる」の3つのステップが行われています。

## 1. PyPIからパッケージをダウンロード（探す）

まず、pipは PyPI（Python Package Index） という、
世界中のライブラリが集まる倉庫へ繋ぎにいきます。

- 指定されたバージョン（指定がなければ最新版）を探す。
- 自分のOS（Windows/Mac/Linux）やPythonのバージョンに合った `ビルド済みファイル（Wheel）`を優先的に探します。

> Wheelファイルとは、、、
> 
> ライブラリなどのプログラムはコード状態だけだと動かず、
> 自分のOSやPythonのバージョンにあった機械語に翻訳する必要があります。
> 
> 事前に翻訳しておいたものが`wheel`ファイルです。

## 2. site-packageディレクトリに配置（置く）

ダウンロードしたファイル（`.whl`ファイルなど）を解凍し、中身を特定のフォルダにコピーします。
その行き先が`site-packages`です。

これが「インストールされた」という状態の実体です。

ちなみに、site-packageがどこにあるのかは次のコマンドで確認できます。

```py
# PATHがどこに通っているか確認できる
python -m site

# 仮想環境だと例えば
# apps/.venv/lib/python3.12/site-packages

# $ ls .venv/lib/python3.12/site-packages
numpy			pip
numpy-2.4.1.dist-info	pip-24.0.dist-info
```

## 3. Pythonがライブラリを見つける仕組み（つなげる）


なぜ`import`するだけで、コピーしたファイルが読み込まれるのでしょうか？

それは、Pythonが起動する時に**ライブラリを探しに行くリスト（検索パス）**を持っているからです。
このリストは`sys.path`と呼ばれます。

よくパスが通っている、通っていないなどの文脈のあれです。

1. Pythonを実行する。
2. `import numpy`と書かれているのを見つける。
3. `sys.path`に登録されているフォルダ（`site-packages`など）を上から順番に覗く。
4. `numpy`というフォルダを見つけたら読み込む！

このように、pipは**Pythonの検索ルート上にある`site-packages`に、物理的にファイルを置く**という非常にシンプルな作業を自動化してくれているのです。

# 「ビルド済み（Wheel）」と「ソースビルド」の違い

`pip install`をしたとき、一瞬で終わることもあれば、
数分間画面が止まった挙句に赤い文字でエラーが出ることもあります。

この差は、「完成品」をダウンロードしているか、「材料」から組み立てているかの違いにあります。

## Wheel (.whl)：手間いらずの「完成品」

多くのメジャーなライブラリは、Wheel という形式で PyPI にアップロードされています。 

これはすでにコンパイル（コンピュータが読める形式に変換）が終わっている「ビルド済み」のファイルです。

ダウンロードして`site-package`に解凍・配置するだけなのですぐ終わるのがメリットです。

たとえば、`numpy-1.26.0-cp310-cp310-manylinux_2_17_x86_64.whl`のようなファイル名になっており、Python3.10用の、64bit Linux用の完成品といった情報が含まれています。

## sdist (.tar.gz)：現場で作る「ソースビルド」

一方で、自分の環境（OS、Pythonのバージョン、CPUアーキテクチャ）にぴったりのWheelがPyPIにない場合、pipは`sdist (Source Distribution)`をダウンロードします。

これはソースコード、つまり「設計図と材料」だけの状態です。

このとき、あなたの手元のマシンで「ビルド（コンパイル）」が始まります。

## CUDAなどの環境はソースビルドが必要になることが多い

特にGPUを使うライブラリ（PyTorchの拡張ライブラリや、特定の画像処理ライブラリなど）で、
このソースビルドが発生しやすいです。

- **ハードウェアへの最適化**: NVIDIAのGPUを使う場合、そのマシンのCUDAツールキットのバージョンやGPUの世代（アーキテクチャ）に合わせて、C++やCUDAのコードを最適にコンパイルする必要があります。
- **依存関係の複雑さ**: 「CUDA11.8と12.1、両方の全パターンに対してWheelを用意する」のは非常に大変なため、特殊な構成の環境では「手元でコンパイルしてね」という形式になります。


# 開発者の強い味方：Editableモード（-e）の仕組み

ライブラリを使っているとき、

「このライブラリの中にデバッグ用のログを仕込みたい」とか、
「自作ライブラリを開発しながら、別のプロジェクトで動作確認したい」という場面があります。

しかし、通常の `pip install`では、コードを書き換えても変更が反映されません。
なぜなら、**インストールした瞬間のコードがsite-packagesにコピーされただけ**だからです。

そこで便利なのが`Editableモード (-e)` です。

## コピーではなく、参照

通常インストールと Editableモードの違いを一言で言うと、
**ファイルをコピーするか、場所を教えるだけにするか**の違いです。

- 通常インストール（`pip install`）
  - ソースコードを`site-packages`にコピーする
  - 元のソースを編集しても、`site-packages`内のファイルは古いまま
- Editableモード（`pip install -e`）
  - ファイルをコピーしない
  - 代わりに「ソースがここにある」という参照情報だけを`site-packages`に保存する


## 内部では.pthファイルが活躍している

「参照を置く」と言っても、OSのシンボリックリンク（ショートカット）を貼っているわけではありません。

Python独自の `.pth (Path Configuration File)`という仕組みを使っています。

Editableモードでインストールすると、`site-packages`の中に
`(パッケージ名).pth`という小さなテキストファイルが生成されます。

この中身を覗いてみると、あなたの開発フォルダの絶対パスが1行書かれているだけです。

- Pythonが起動する。
- `site-packages`を見に行く。
- `.pth`ファイルを見つける。
- 「あ、ここ（開発フォルダ）もライブラリの探し場所に追加しなきゃ」と認識する。

この仕組みのおかげで、開発フォルダでコードを書き換えた瞬間に、
次にimportしたときには最新のコードが読み込まれるようになります。


## `-e .`と`setup.py develop`は何が違う？

昔の主流は`python setup.py develop`でした。

このコマンドも同じようにEditableモードで`-e .`と同じです。
ただ、現在は`pip install -e .`が推奨されています。

> `.`の意味 
> 
> `pip install -e .`の最後にあるドットは「現在のディレクトリ」を指します。
> つまり、「今自分がいるこの開発フォルダを、Editableモードでインストールしてね」という意味になります。


# まとめ

本記事では、

- pip installの内部の動き
- Wheelとソースビルド
- Editableモード

についてざっくり解説していきました。

単にコマンドを知っているだけでなく、
内部で「ファイルがどう動いているか」を知っていると、トラブルへの対応力が変わります。

- 「インポートできない？なら`sys.path`と`site-packages`を確認しよう」 
- 「ビルドエラーが出た？なら C++ コンパイラや CUDA の設定を見直そう」 
- 「コードを変更しても反映されない？なら`-e`モードを使おう」

このように、一つ一つのエラーに対して、根拠を持って対処できるようになるはずです。 

- 参考
  - https://pip.pypa.io/en/stable/
  - https://packaging.python.org/en/latest/

