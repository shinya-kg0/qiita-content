---
title: pip installって何してるの？
tags:
  - 'Python'
  - '初心者'
private: false
updated_at: ''
id: null
organization_url_name: null
slide: false
ignorePublish: true
---
# はじめに

Pythonでプログラミングをしていると、当たり前のように使っている`pip install`コマンド。
このコマンド一つで、便利なライブラリがすぐに使えるようになります。

しかし、**結局、pipは何をどこにダウンロードして、どうやってPythonがそれを見つけているのか？**を詳しく知っている人は意外と少ないかもしれません。

普段は意識しなくても開発は進められますが、
以下のような場面では内部の仕組みを理解していると役立ちます。

- ライブラリをインストールしたはずなのに`ModuleNotFoundError`が出るというトラブルの解決
- 特定のプロジェクトだけで自作ライブラリを使い回したいときの構成
- 複数のライブラリのバージョン競合（依存関係）で詰まったときの原因究明


この記事では、pip installが内部でどのような処理を行っているのかを、できるだけシンプルに解説します。


# pip installの基本的な流れ

`pip install`を実行したとき、内部では大きく分けて
「探す」「置く」「つなげる」の3つのステップが行われています。

## 1. PyPIからパッケージをダウンロード（探す）

まず、pipは PyPI（Python Package Index） という、
世界中のライブラリが集まる倉庫へ繋ぎにいきます。

- 指定されたバージョン（指定がなければ最新版）を探す。
- 自分のOS（Windows/Mac/Linux）やPythonのバージョンに合った `ビルド済みファイル（Wheel）`を優先的に探します。

ライブラリなどのプログラムはコード状態だけだと動かず、
自分のOSやPythonのバージョンにあった機械語に翻訳する必要があります。

事前に翻訳しておいたものが`wheel`ファイルです。

## 2. site-packageディレクトリに配置（置く）

ダウンロードしたファイル（`.whl`ファイルなど）を解凍し、中身を特定のフォルダにコピーします。
その行き先が`site-packages`です。

これが「インストールされた」という状態の実体です。

ちなみに、site-packageがどこにあるのかは次のコマンドで確認できます。

```py
# PATHがどこに通っているか確認できる
python -m site

# 仮想環境だと例えば
# apps/.venv/lib/python3.12/site-packages

# $ ls .venv/lib/python3.12/site-packages
numpy			pip
numpy-2.4.1.dist-info	pip-24.0.dist-info
```

## 3. Pythonがライブラリを見つける仕組み（つなげる）


なぜ`import`するだけで、コピーしたファイルが読み込まれるのでしょうか？

それは、Pythonが起動する時に**ライブラリを探しに行くリスト（検索パス）**を持っているからです。
このリストは`sys.path`と呼ばれます。

よくパスが通っている、通っていないなどの文脈のあれです。

1. Pythonを実行する。
2. `import numpy`と書かれているのを見つける。
3. `sys.path`に登録されているフォルダ（`site-packages`など）を上から順番に覗く。
4. `numpy`というフォルダを見つけたら読み込む！

このように、pipは**Pythonの検索ルート上にある`site-packages`に、物理的にファイルを置く**という非常にシンプルな作業を自動化してくれているのです。

# 「ビルド済み（Wheel）」と「ソースビルド」の違い

`pip install`をしたとき、一瞬で終わることもあれば、
数分間画面が止まった挙句に赤い文字でエラーが出ることもあります。

この差は、「完成品」をダウンロードしているか、「材料」から組み立てているかの違いにあります。

## Wheel (.whl)：手間いらずの「完成品」

多くのメジャーなライブラリは、Wheel という形式で PyPI にアップロードされています。 

これはすでにコンパイル（コンピュータが読める形式に変換）が終わっている「ビルド済み」のファイルです。

ダウンロードして`site-package`に解凍・配置するだけなのですぐ終わるのがメリットです。

たとえば、`numpy-1.26.0-cp310-cp310-manylinux_2_17_x86_64.whl`のようなファイル名になっており、Python3.10用の、64bit Linux用の完成品といった情報が含まれています。

## sdist (.tar.gz)：現場で作る「ソースビルド」

一方で、自分の環境（OS、Pythonのバージョン、CPUアーキテクチャ）にぴったりのWheelがPyPIにない場合、pipは`sdist (Source Distribution)`をダウンロードします。

これはソースコード、つまり「設計図と材料」だけの状態です。

このとき、あなたの手元のマシンで「ビルド（コンパイル）」が始まります。

## CUDAなどの環境はソースビルドが必要になることが多い

特にGPUを使うライブラリ（PyTorchの拡張ライブラリや、特定の画像処理ライブラリなど）で、
このソースビルドが発生しやすいです。

- **ハードウェアへの最適化**: NVIDIAのGPUを使う場合、そのマシンのCUDAツールキットのバージョンやGPUの世代（アーキテクチャ）に合わせて、C++やCUDAのコードを最適にコンパイルする必要があります。
- **依存関係の複雑さ**: 「CUDA11.8と12.1、両方の全パターンに対してWheelを用意する」のは非常に大変なため、特殊な構成の環境では「手元でコンパイルしてね」という形式になります。

