---
title: おいしいCookie、まずいCookie
tags:
  - 初心者
  - cookie
  - アンチパターン
private: false
updated_at: '2025-12-21T10:45:26+09:00'
id: 8fd3334e95e5f9ded29d
organization_url_name: null
slide: false
ignorePublish: false
---
# はじめに

最近、[［改訂新版］プロになるためのWeb技術入門](https://gihyo.jp/book/2024/978-4-297-14571-2)を読みCookieの話が出てきたので、
どんな風に使っていくか、アンチパターンなどをまとめてみました。

## Cookieとは 🍪

簡単にCookieって何？どんなことができるの？などを説明します。

> Cookie（ウェブ Cookie、ブラウザー Cookie とも呼ぶ）は、サーバーがユーザーのウェブブラウザーに送信する小さなデータです。ブラウザーは Cookie を保存したり、新しい Cookie を作成したり、既存の Cookie を変更したり、後でリクエストされたときに同じサーバーにそれらを送り返したりすることができます。 Cookie により、ウェブアプリケーションは限られた量のデータを格納し、状態についての情報を記憶することができます。HTTP プロトコルは既定ではステートレスだからです。
>
> https://developer.mozilla.org/ja/docs/Web/HTTP/Guides/Cookies


細かく書かれていますが、  
要は、**Cookieは「ブラウザに保存される小さなメモ**です。

サーバーが「次回また来たときに、誰か分かるように」ブラウザに渡す識別情報を持っています。

### Cookieがないとどうなる？

前提としてクライアント（ブラウザ）とサーバーとのやりとりはHTTP通信で行われています。  
ただ、HTTP通信は**1回の通信毎に完結する設計**になっています。（ステートレス）

ということは、サーバーは通信した記憶をすぐに忘れてしまい、  
次のリクエストを投げてもさっきと同じユーザーだということがわかりません。

これは何が不便なのでしょうか？？

Chromeなどのブラウザを使ってECサイトを利用するケースで考えてみます。

あなたは、ある商品Aをカートに入れました。  
次に商品Bのページを見に行くとカートの中の商品Aが無くなっています。。。

あなた（ユーザー）の情報を保持できずに、一回きりの通信しか対応できません。

他にもそもそもログイン情報を保持できないので、  
毎回IDとパスワードを入力する手間や、ユーザーの設定も毎回リセットされます。

現代の複雑なWebアプリケーションで情報が保持できないのは致命傷ですよね、、、

### ステートフルを実現する

このような課題を解決するのがCookieです。

一回きりのHTTP通信でも、ユーザーとのやり取り（セッション）やユーザーを一意に特定できれば情報を保持し継続性を持たせることができます。

> セッションとは、、、
>
> クライアントとサーバーの「一連のやりとり」です。  
> たとえば、居酒屋に入って注文、追加などで伝票（セッションID）が付けられ、お会計までの一連の流れのことです。
> 

Cookieの中に、ユーザーやセッションを特定するIDを持たせることで実現しています。

「ならCookieの中に全てカート内の情報などを持たせたらどうなの？」という疑問もあると思います。

Cookieは大量な情報を持っておくことを目的としていない、改ざんによるセキュリティリスクなどがあるので避けた方が良いです。

基本的な情報処理はサーバー側にさせた方が良いので、  
Cookieは**ユーザーやセッションを特定するタグ（ラベル）を持っている**というイメージです。

セッションIDやユーザーIDなどが流出すると、  
それらのやりとりが乗っ取られるのでCookieの扱いは注意が必要です。

そのあたり”まずいCookie”パートで説明していきます。


# おいしいCookie 😋

このパートでは、抑えておきたいCookieの設定のポイントを整理していきます。

| **属性名** | **推奨される値** | **設定する理由（メリット）** | **設定しない際のリスク** |
| --- | --- | --- | --- |
| **HttpOnly** | `true` | JavaScriptからのアクセスを禁止し、XSSによるトークン奪取を防ぐ。 | XSS脆弱性があった場合、`document.cookie`で即座に秘密情報が盗まれる。 |
| **Secure** | `true` | HTTPS通信時のみCookieを送信するように制限する。 | HTTP通信（公衆無線LAN等）でパケットキャプチャされ、盗聴される。 |
| **SameSite** | `Lax` (または `Strict`) | クロスサイトリクエストでの送信を制限し、CSRF攻撃を防御する。 | 他のサイトから勝手にリクエスト（退会処理や送金など）を投げられる。 |
| **Path** | `/` | サイト内の全パスでCookieを有効にする（意図的でない限り限定しない）。 | パスを絞りすぎると、特定のディレクトリでログイン状態が維持されないバグを生む。 |
| **Domain** | **指定しない** (省略) | 現在のホストのみに限定する。サブドメインへの漏洩を防ぐ。 | サブドメインで設定したものが本体等で上書き・窃取される。 |
| **Max-Age / Expires** | セッションCookie（未設定）<br>または短期間（3600〜86400秒） | 有効期限を明示的に管理し、古いセッションを自動削除する。セッションCookieはブラウザ終了時に削除される。 | 無期限や長期間（数年）の設定は、端末紛失・盗難時の被害期間を延長させる。GDPRなどで「最小保持期間」違反の可能性。 |
| **Prefix: __Host-** | `__Host-session_id` 形式 | `Secure`+`Path=/`+`Domain未指定`を強制する。サーバー側での厳格な検証が不要になる。 | 攻撃者がサブドメインやHTTPで同名Cookieを上書きし、セッション固定攻撃を仕掛けられる可能性。 |
| **Prefix: __Secure-** | `__Secure-user_pref` 形式 | `Secure`属性を強制する。HTTPSでのみ設定・送信されることが保証される。 | HTTP通信で同名Cookieが設定され、中間者攻撃でセキュアなCookieが上書きされる（ダウングレード攻撃）。 |


基本的にはすべて設定した方が良いと思います。  
（セキュリティの厳格さは利便性とのトレードオフなので要件次第ですが、、、）

設定する値としては次のようなイメージになります。

```bash
# セッション管理用の設定イメージ
Set-Cookie: __Host-session_id=abc123def; Secure; HttpOnly; SameSite=Lax; Path=/
```

# まずいCookie 🤮

Cookieは便利な技術で、現代のWeb開発には必須の知識になっています。

しかし、正しく設定しないと簡単にセキュリティリスクに繋がります。

よくある落とし穴に落ちないように、アンチパターンに触れていきましょう。

もちろん以下のものだけではありません。  
実装時にベテランの方に相談するのもいいかもしれませんね。



| **アンチパターン** | **起こりうる最悪のケース** | **改善後のアクション** |
| --- | --- | --- |
| **生データの保持** | 権限昇格・個人情報漏洩 | サーバー側セッション管理に移行 |
| **LocalStorage保存** | 全ユーザーのセッション乗っ取り | `HttpOnly` Cookieへ移行 |
| **広いDomain設定** | サブドメイン経由の攻撃 | Domain属性を削除（省略） |
| **巨大なCookie** | サイトが重い・431エラー | `LocalStorage` または DBへ移行 |
| **SameSite=None** | CSRF攻撃による勝手な操作 | `SameSite=Lax` をデフォルトにする |


## 1. 生データの保持

最も基本的かつ危険なアンチパターンです。

具体的には次のような情報をCookieに書くとまずいです。

- 権限フラグ（`isAdmin=true`）
- 会員ランク（`rank=premium`）
- ポイント残高（`points=10000`）

※ユーザーIDやメールアドレスも、それ単体で認証・認可の判断をする設計は危険です。


### なぜダメなのか？

- 改ざんのリスク
  - Cookieはブラウザ側で自由に書き換え可能です。`isAdmin=false`を`true`に書き換えるだけで管理者権限を奪取できるような設計は致命的です。
- 情報漏洩のリスク
  - `HTTPOnly`の設定を忘れていたり、XSS脆弱性があった場合、ユーザーの個人情報がそのまま盗まれます。

### どうすれば防げる？

Cookieには**サーバー側のDBを参照するためのランダムなセッションID**のみを入れ、  
具体的なデータは全てサーバー側で管理します。


## 2. LocalStorage保存

JWTやセッションIDを`localStorage.setItem()`で保存するとまずいです。
SPA（React/Vueなど）の開発で非常によく見られる誤りです。

### なぜダメなのか？

- XSSに対して無防備
  - LocalStorageはJavaScriptから100%アクセス可能です。悪意のあるスクリプト（XSS）が1つ実行されただけで、そのサイトの全ユーザーのトークンが一瞬で盗まれます。


### どうすれば防げる？

認証情報は必ず `HttpOnly`属性をつけたCookieに保存します。
これにより、JavaScriptからのアクセスを物理的に遮断できます。

一方、UIの状態やユーザー設定など、盗まれても被害が少ない情報であれば
LocalStorageを使っても問題ありません。重要なのは「何を保存するか」の判断です。


## 3. 広いDomain設定

`Domain=.example.com`のように、トップドメインを指定して発行する。
サブドメインを運用しているサービスでよくある落とし穴です。

### なぜダメなのか？

- サブドメイン間の影響
  - `test.example.com`のような、セキュリティ管理が甘いサブドメインが攻撃された際、その攻撃者が本番ドメイン（`example.com`）のCookieを盗んだり、偽のCookieを上書きしたりできるようになります。


### どうすれば防げる？

**Domain属性は「指定しない」のがベスト**です。指定しなければ、そのCookieを発行したホスト（例：www.example.com）だけでしか有効にならず、最も安全です。


## 4. 巨大なCookie

ユーザーの閲覧履歴、複雑な検索条件、UIの状態などをすべてCookieに入れる。
「とりあえず保存しておこう」という安易な考えが招くトラブルです。


### なぜダメなのか？

- 通信の肥大化
  - Cookieは、そのドメインへの「すべてのリクエスト（画像、CSS、JS含む）」に自動で添付されます。Cookieが4KBあれば、画像1枚取得するたびに4KBの無駄な通信が発生し、サイトが重くなります。
- 431エラー
  - HTTPヘッダーがサーバーの許容上限（通常8KB〜16KB）を超えると、サーバーはリクエストを拒否（`431 Request Header Fields Too Large`）します。

### どうすれば防げる？

クライアント側だけで使うデータなら`LocalStorage`を使い、
サーバーに送る必要がある大きなデータはDBに保存してIDだけをやり取りします。

## 5. SameSite=None

`SameSite=None; Secure`を設定して、どこからでもCookieが送られるようにする。
「Cookieが送られなくて動かないから、とりあえずNoneにしよう」という対応です。


### なぜダメなのか？

- CSRF（クロスサイトリクエストフォージェリ）への無防備
  - `None`にすると、悪意のある外部サイトに貼られたリンクやボタンをクリックした際にもCookieが送信されます。これにより、勝手に退会させられたり、情報を書き換えられたりする攻撃が可能になります。


### どうすれば防げる？

原則として `SameSite=Lax`を使い、どうしてもクロスサイトでの送信が必要な場合（iframe内での利用など）のみ、最小限の範囲で`None`を検討します。その際は`Partitioned`(CHIPS)属性の併用を検討すべきです。

# さいごに

Cookieという現代に欠かせない技術について、  
推奨パターンとアンチパターンを整理してみました。

これだけが絶対の正解ということは決してありませんが、  
理解のレベルがCookieとは？からざっくり何に気をつけるかわかるようになれば嬉しいです。

「こんなセキュリティリスクがあるからこの設定が必要」  
というような理解をしておくと実戦で使えるものになると思いました。
