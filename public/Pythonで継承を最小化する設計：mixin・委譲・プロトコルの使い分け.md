---
title: Pythonで継承を最小化する設計：mixin・委譲・プロトコルの使い分け.md
tags:
  - 'Python'
  - '継承'
  - 'オブジェクト指向'
private: false
updated_at: ''
id: null
organization_url_name: null
slide: false
ignorePublish: true
---
# はじめに

[達人プログラマー](https://www.ohmsha.co.jp/book/9784274226298/)という本を読んでいて、
**継承は避けた方がいい**という内容を見つけました。

> オブジェクト指向言語でプログラムを開発しているのでしょうか？そうであれば、インケリタンス（継承）を使っているのでしょうか？
> 答えがイエスなのであれば、今すぐ手を止めてください！これはおそらくあなたがやりたいことと思っていることではありません。
>
> 引用：[達人プログラマー](https://www.ohmsha.co.jp/book/9784274226298/)

私はPythonをメインに使っているので、継承という概念は知っていますが、
落とし穴や代替方法についてはよく知らなかったのでまとめました。

仕事の中で、継承の選択肢が出てきた時に思い返すと、
潜在的なバグを防げるかもしれません、、、

## 対象者

- オブジェクト指向言語を扱っていて、なんとなく継承という概念を知っている。
- 継承関連のバグに遭遇したことがある。

# 継承とは？

ざっくり説明すると、基本的な機能を引き継ぎ、新たな機能を追加したり、
既存の機能を書き換えることができる仕組みです！

具体例についてはこちらの記事がわかりやすかったので、おすすめです。
→ [初学者のためのPython講座　オブジェクト指向編5　クラスの継承](https://qiita.com/kotakahe/items/b678250389af7fa885a5)

コードの再利用ができたり、クラスの柔軟性が上がるというメリットがあって、
便利そうですが、何が問題なのでしょうか？？

## 継承のデメリット

考えられるデメリットを並べてみます。

1. 親クラスの変更が子クラスに思わぬ影響を与える
→ 親クラスに定義していた共通処理を変更する時、それを継承している子クラスに影響を与える可能性がある。

2. 不要な機能も引き継いでしまう
→ 子クラスが親クラスのメソッドを使わないとしても、インターフェースとして残ってしまう。

3. 継承階層が深くなって複雑になる
→ 親の親クラスの定義をみにいく必要があるなど、理解が難しくなる

4. 多重継承のあいまいさ
→ 複数の親クラスを継承していると、どの親クラスのメソッドか分かりづらくなる  
（多重継承については、メソッド解決順序（MRO）の概念の理解が必要です。）
 [「Pythonのメソッド順序解決を理解する」](https://qiita.com/y518gaku/items/7c00afb1e887ed449788)がわかりやすかったです。


具体例で考えてみましょう。
次のように定義してみます。

```py
class Animal:
  def __init__(self, name):
    self.name = name

  def speak(self):
    print(f"{self.name} は鳴きます！")

class Dog(Animal):
  def speak(self):
    print("ワンワン！")
```

出力は以下のようになります。

```py
dog = Dog("ポチ")
dog.speak()
# => ワンワン！
```

ここで、親クラスの定義を変えてみましょう。

```py
class Animal:
  def __init__(self, name):
    self.name = name

  def speak(self, sound):
    # 鳴き声もしていできるようにする
    print(f"{self.name} は{sound}と鳴きます！")

class Dog(Animal):
  def speak(self):
    print("ワンワン！")
```

この呼び出し方だと、親クラスの定義変更が子クラスに伝わってません（期待通り反映されてない）。
想定外の動きになるので、潜在的にバグになっています。

```py
dog = Dog("ポチ")
dog.speak()
# => ワンワン！
```

次に、引数を与えてみるとどうでしょうか？

```py
dog = Dog("ポチ")
dog.speak("ワン")  
# => TypeError: Dog.speak() takes 1 positional argument but 2 were given
```

子クラスのspeakメソッドが呼び出されるため、
引数の数が異なりエラーになります。

これぐらいシンプルな例だと、「さすがにそんなことしないよ、、、」となると思いますが、
コードが大きくなってくると、なかなか気づかない可能性も出てきます。
