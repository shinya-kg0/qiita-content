---
title: 【Python】関数を呼び忘れてif文が常にTrueになった話
tags:
  - Python
  - バグ
private: false
updated_at: '2025-11-16T13:26:25+09:00'
id: 8ce4b911df0a31a8460c
organization_url_name: null
slide: false
ignorePublish: false
---

# **はじめに**

最近、仕事中に「え？なんでここ常に True になるの……？」というバグに遭遇しました。

原因はシンプルでありながら、意外と気づきにくい **関数の呼び忘れ** でした。

Pythonでは関数が“第一級オブジェクト”として扱われるため、
**関数そのものを if 文で評価すると True になってしまう** という仕様があります。

この記事では、実際に起きたバグをもとに、その原因と対処法をまとめます。


# **バグが発生した背景**

あるソースコード変更後、CI が突然こけるように。

変更点も多く、原因の特定に時間がかかりました。

調べてみると、実はとても単純なバグでした。

## **本来意図していたコード**

```python
def is_valid(obj):
    if obj == "hogehoge":
        return True
    else:
        return False

item = "piyopiyo"

if is_valid(item):
    # True の場合の処理
else:
    # False の場合の処理
```

is_valid(item) の返り値に応じて処理が分岐する、よくある書き方ですね。

## **実際に書かれていたバグのコード**

```python
# 引数がない、、、
if is_valid:
    # True の場合の処理
else:
    # False の場合の処理
```

**引数の指定が抜けていた**ため、is_valid という「関数オブジェクトそのもの」を if 文に渡してしまっています。

この状態だと、**常に True**になります、、、

理由は後述しますが、**関数オブジェクトは truthy（真と判定される）** ため、
この条件分岐は絶対に if 側に入ります。しかもエラーは出ません。（なかなか厄介ですね。）


# **Pythonの「第一級オブジェクト」が原因**

ポイントはここです。

**Pythonの関数はオブジェクト**

- 関数は「値」として扱える
- 変数に代入できる
- 引数に渡したり、リストに入れたりできる
- if 文で評価すると “存在するだけで True”

つまり is_valid と書くと、

「関数 is_valid の実体」の参照を表します。

## **真偽値として評価するとどうなる？**

```
if is_valid:  # ← 関数オブジェクト
```

→ 関数オブジェクトは常に truthy
→ したがって常に True

意図していた「関数を実行した結果の True/False」ではなく
**関数そのものを評価してしまった**ために発生したバグでした。



# **対策：どうすれば防げた？**

## **1. とにかく “() を忘れない”**

呼ぶべき関数は必ず () を付ける。
特に条件分岐と関数呼び出しを組み合わせるときに注意するとよさそうです。



## **2. 関数オブジェクトを利用する場面も理解する**

下記のように「関数そのものを渡す」が正しいケースもあるため、区別が重要です。

```
callbacks = [check_a, check_b, check_c]
```

## **3. 静的解析ツールを導入する**

flake8 や pylint では「関数の呼び忘れ」を警告してくれるケースがあります。

注意としては、Pythonとしては問題なく実行できることです。
結果が妥当かを確認する手段（自動テストなど）を合わせて用意しておくことで、
見つけづらいバグを防げます。




# **まとめ**

Python は関数を第一級オブジェクトとして扱える、とても柔軟な言語です。
一方で、今回のように **“呼び忘れ” がバグとして静かに潜む** ケースもあります。

- 関数を呼ぶ
- 関数そのものを渡す

この2つを常に意識しておくことが、バグを減らす一歩になります。

自分が使っている言語の仕様について、
少しずつ理解を深めていくことが大事だと思いました。
